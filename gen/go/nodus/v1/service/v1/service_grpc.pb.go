// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: nodus/v1/service/v1/service.proto

package servicev1

import (
	context "context"
	v11 "github.com/spounge-ai/spounge-proto/gen/go/nodus/v1/mcp/v1"
	v1 "github.com/spounge-ai/spounge-proto/gen/go/nodus/v1/nodes/v1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	NodusService_ExecuteNode_FullMethodName       = "/nodus.v1.service.v1.NodusService/ExecuteNode"
	NodusService_ExecuteNodeStream_FullMethodName = "/nodus.v1.service.v1.NodusService/ExecuteNodeStream"
	NodusService_RegisterMCPServer_FullMethodName = "/nodus.v1.service.v1.NodusService/RegisterMCPServer"
	NodusService_ListMCPServers_FullMethodName    = "/nodus.v1.service.v1.NodusService/ListMCPServers"
	NodusService_QueryMCPTools_FullMethodName     = "/nodus.v1.service.v1.NodusService/QueryMCPTools"
	NodusService_CheckHealth_FullMethodName       = "/nodus.v1.service.v1.NodusService/CheckHealth"
)

// NodusServiceClient is the client API for NodusService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodusServiceClient interface {
	ExecuteNode(ctx context.Context, in *v1.ExecuteNodeRequest, opts ...grpc.CallOption) (*v1.ExecuteNodeResponse, error)
	ExecuteNodeStream(ctx context.Context, in *v1.ExecuteNodeStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[v1.ExecuteNodeStreamResponse], error)
	RegisterMCPServer(ctx context.Context, in *v11.RegisterMCPServerRequest, opts ...grpc.CallOption) (*v11.RegisterMCPServerResponse, error)
	ListMCPServers(ctx context.Context, in *v11.ListMCPServersRequest, opts ...grpc.CallOption) (*v11.ListMCPServersResponse, error)
	QueryMCPTools(ctx context.Context, in *v11.QueryMCPToolsRequest, opts ...grpc.CallOption) (*v11.QueryMCPToolsResponse, error)
	CheckHealth(ctx context.Context, in *CheckHealthRequest, opts ...grpc.CallOption) (*CheckHealthResponse, error)
}

type nodusServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNodusServiceClient(cc grpc.ClientConnInterface) NodusServiceClient {
	return &nodusServiceClient{cc}
}

func (c *nodusServiceClient) ExecuteNode(ctx context.Context, in *v1.ExecuteNodeRequest, opts ...grpc.CallOption) (*v1.ExecuteNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v1.ExecuteNodeResponse)
	err := c.cc.Invoke(ctx, NodusService_ExecuteNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodusServiceClient) ExecuteNodeStream(ctx context.Context, in *v1.ExecuteNodeStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[v1.ExecuteNodeStreamResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &NodusService_ServiceDesc.Streams[0], NodusService_ExecuteNodeStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[v1.ExecuteNodeStreamRequest, v1.ExecuteNodeStreamResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type NodusService_ExecuteNodeStreamClient = grpc.ServerStreamingClient[v1.ExecuteNodeStreamResponse]

func (c *nodusServiceClient) RegisterMCPServer(ctx context.Context, in *v11.RegisterMCPServerRequest, opts ...grpc.CallOption) (*v11.RegisterMCPServerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v11.RegisterMCPServerResponse)
	err := c.cc.Invoke(ctx, NodusService_RegisterMCPServer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodusServiceClient) ListMCPServers(ctx context.Context, in *v11.ListMCPServersRequest, opts ...grpc.CallOption) (*v11.ListMCPServersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v11.ListMCPServersResponse)
	err := c.cc.Invoke(ctx, NodusService_ListMCPServers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodusServiceClient) QueryMCPTools(ctx context.Context, in *v11.QueryMCPToolsRequest, opts ...grpc.CallOption) (*v11.QueryMCPToolsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(v11.QueryMCPToolsResponse)
	err := c.cc.Invoke(ctx, NodusService_QueryMCPTools_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodusServiceClient) CheckHealth(ctx context.Context, in *CheckHealthRequest, opts ...grpc.CallOption) (*CheckHealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckHealthResponse)
	err := c.cc.Invoke(ctx, NodusService_CheckHealth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodusServiceServer is the server API for NodusService service.
// All implementations must embed UnimplementedNodusServiceServer
// for forward compatibility.
type NodusServiceServer interface {
	ExecuteNode(context.Context, *v1.ExecuteNodeRequest) (*v1.ExecuteNodeResponse, error)
	ExecuteNodeStream(*v1.ExecuteNodeStreamRequest, grpc.ServerStreamingServer[v1.ExecuteNodeStreamResponse]) error
	RegisterMCPServer(context.Context, *v11.RegisterMCPServerRequest) (*v11.RegisterMCPServerResponse, error)
	ListMCPServers(context.Context, *v11.ListMCPServersRequest) (*v11.ListMCPServersResponse, error)
	QueryMCPTools(context.Context, *v11.QueryMCPToolsRequest) (*v11.QueryMCPToolsResponse, error)
	CheckHealth(context.Context, *CheckHealthRequest) (*CheckHealthResponse, error)
	mustEmbedUnimplementedNodusServiceServer()
}

// UnimplementedNodusServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNodusServiceServer struct{}

func (UnimplementedNodusServiceServer) ExecuteNode(context.Context, *v1.ExecuteNodeRequest) (*v1.ExecuteNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteNode not implemented")
}
func (UnimplementedNodusServiceServer) ExecuteNodeStream(*v1.ExecuteNodeStreamRequest, grpc.ServerStreamingServer[v1.ExecuteNodeStreamResponse]) error {
	return status.Errorf(codes.Unimplemented, "method ExecuteNodeStream not implemented")
}
func (UnimplementedNodusServiceServer) RegisterMCPServer(context.Context, *v11.RegisterMCPServerRequest) (*v11.RegisterMCPServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterMCPServer not implemented")
}
func (UnimplementedNodusServiceServer) ListMCPServers(context.Context, *v11.ListMCPServersRequest) (*v11.ListMCPServersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMCPServers not implemented")
}
func (UnimplementedNodusServiceServer) QueryMCPTools(context.Context, *v11.QueryMCPToolsRequest) (*v11.QueryMCPToolsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryMCPTools not implemented")
}
func (UnimplementedNodusServiceServer) CheckHealth(context.Context, *CheckHealthRequest) (*CheckHealthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckHealth not implemented")
}
func (UnimplementedNodusServiceServer) mustEmbedUnimplementedNodusServiceServer() {}
func (UnimplementedNodusServiceServer) testEmbeddedByValue()                      {}

// UnsafeNodusServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodusServiceServer will
// result in compilation errors.
type UnsafeNodusServiceServer interface {
	mustEmbedUnimplementedNodusServiceServer()
}

func RegisterNodusServiceServer(s grpc.ServiceRegistrar, srv NodusServiceServer) {
	// If the following call pancis, it indicates UnimplementedNodusServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NodusService_ServiceDesc, srv)
}

func _NodusService_ExecuteNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ExecuteNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodusServiceServer).ExecuteNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodusService_ExecuteNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodusServiceServer).ExecuteNode(ctx, req.(*v1.ExecuteNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodusService_ExecuteNodeStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v1.ExecuteNodeStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NodusServiceServer).ExecuteNodeStream(m, &grpc.GenericServerStream[v1.ExecuteNodeStreamRequest, v1.ExecuteNodeStreamResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type NodusService_ExecuteNodeStreamServer = grpc.ServerStreamingServer[v1.ExecuteNodeStreamResponse]

func _NodusService_RegisterMCPServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v11.RegisterMCPServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodusServiceServer).RegisterMCPServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodusService_RegisterMCPServer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodusServiceServer).RegisterMCPServer(ctx, req.(*v11.RegisterMCPServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodusService_ListMCPServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v11.ListMCPServersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodusServiceServer).ListMCPServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodusService_ListMCPServers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodusServiceServer).ListMCPServers(ctx, req.(*v11.ListMCPServersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodusService_QueryMCPTools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v11.QueryMCPToolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodusServiceServer).QueryMCPTools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodusService_QueryMCPTools_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodusServiceServer).QueryMCPTools(ctx, req.(*v11.QueryMCPToolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodusService_CheckHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckHealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodusServiceServer).CheckHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodusService_CheckHealth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodusServiceServer).CheckHealth(ctx, req.(*CheckHealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NodusService_ServiceDesc is the grpc.ServiceDesc for NodusService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodusService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nodus.v1.service.v1.NodusService",
	HandlerType: (*NodusServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ExecuteNode",
			Handler:    _NodusService_ExecuteNode_Handler,
		},
		{
			MethodName: "RegisterMCPServer",
			Handler:    _NodusService_RegisterMCPServer_Handler,
		},
		{
			MethodName: "ListMCPServers",
			Handler:    _NodusService_ListMCPServers_Handler,
		},
		{
			MethodName: "QueryMCPTools",
			Handler:    _NodusService_QueryMCPTools_Handler,
		},
		{
			MethodName: "CheckHealth",
			Handler:    _NodusService_CheckHealth_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ExecuteNodeStream",
			Handler:       _NodusService_ExecuteNodeStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "nodus/v1/service/v1/service.proto",
}
